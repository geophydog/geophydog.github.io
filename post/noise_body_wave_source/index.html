<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Locating Microseismic Body Wave Sources from Noise Cross-correlation - Geophydog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Geophydog" /><meta name="description" content="Short background Ambient noise tomography of regional and continental scales is much benefited from the system composed of the atmosphere, ocean and the solid earth. Ambient noise below 1Hz is largely due to oceans, and interactions between ocean waves and/or the sea floor generate pressure impulse propagating into the solid earth. Land seismic stations are seizing seismic waves which originating from microseisms, and these seismic waves include surface waves and body waves. Individuals can easily retrieve surface waves from ambient noise cross-correlations. Body wave extraction from ambient noise, however, remains difficult. We often explore body waves from ambient noise using array stacking techniques for array stacking leads to high signal-to-noise ratios. Here we perform the body wave source location utilizing beamforming and back-projection methods, and we process one-day seismic recordings by a seismic array in China, which reveals that the source location is in the North Atlantic Ocean, the south of Iceland.
Data and Methods We collect one-day continuous seismic data of vertical component(here BHZ, 2008-03-10) recorded by a seismic array nearly in the center part of China (see the following figure), and compute the cross-spectral matrix using one-hour length segment with a overlap of 50% (1800 seconds): $$ C(\omega) = \frac{1}{N}\sum_{n=1}^N\boldsymbol{u}_n(\omega) \cdot \boldsymbol{u}_n^H(\omega), \tag{1} $$ in which, $\boldsymbol{u}_n(\omega)=[u^1_n(\omega), u^2_n(\omega), \cdots, u^M_n]^T$ is the Fourier spectra of the $n_{th}$ segment data recorded by $M$ stations, $H$ denotes Hermitian transpose, and $N$ is the total number of data segments. Then we create steering vector as follows, $$ \boldsymbol{a}(\omega; \boldsymbol{s}, \boldsymbol{x}) = [e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_1}, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_2}, \cdots, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_M}]^T, \tag{2} $$
where, $\boldsymbol{s}$ and $\boldsymbol{x}_m$ separately indicate horizontal slowness (ray parameter for body waves) and position of the $m_{th}$ station. The beam power is given by $$ B(\omega; \boldsymbol{s}) = \boldsymbol{a}^H \boldsymbol{C}(\omega) \boldsymbol{a}. \tag{3} $$ For more details about beamforming, someone can refer to this blog.
An Example of Locating the distant P wave source We first import required Python libraries.
1 2 3 4 5 6 7 8 import numpy as np import matplotlib.pyplot as plt from obspy import read from glob import glob from mpl_toolkits.basemap import Basemap from scipy.signal.windows import hann import matplotlib as mpl from obspy.taup import TauPyModel The 13 seismic stations are installed in the center part of China, and we collect the data of March 10, 2008 to perform this work.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 files = sorted(glob(&amp;#39;2008-03-10/*BHZ.SAC&amp;#39;)) sta = {} with open(&amp;#39;X4_IRIS_BHZ.txt&amp;#39;, &amp;#39;r&amp;#39;) as fin: for line in fin.readlines(): tmp = line.strip().split(&amp;#39;|&amp;#39;) sta[tmp[1]] = [float(tmp[3]), float(tmp[2])] xy = [] for f in files: tmp = f.split(&amp;#39;/&amp;#39;)[-1].split(&amp;#39;.&amp;#39;)[1] xy.append(sta[tmp]) xy = np.array(xy) plt.figure(figsize=(12, 4.5)) plt.subplot2grid((1, 3), (0, 0), rowspan=1, colspan=2) bmap1 = Basemap(projection=&amp;#39;cyl&amp;#39;, lon_0=0) bmap1.shadedrelief(scale=0.2) xx, yy = bmap1(106, 34) bmap1.scatter(xx, yy, marker=&amp;#39;v&amp;#39;, s=200, facecolor=&amp;#39;#87CEFA&amp;#39;, edgecolor=&amp;#39;k&amp;#39;, lw=1, alpha=1) bmap1.drawmeridians(meridians=np.linspace(-180, 180, 7), labels=[0, 0, 0, 1], color=&amp;#39;none&amp;#39;, fontsize=17) bmap1.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], color=&amp;#39;none&amp;#39;, fontsize=17) plt.subplot2grid((1, 3), (0, 2), rowspan=1, colspan=1) bmap2 = Basemap(projection=&amp;#39;merc&amp;#39;, llcrnrlat=30, llcrnrlon=100, urcrnrlon=110, urcrnrlat=39) bmap2.shadedrelief(scale=1) xx, yy = bmap2(xy[:, 0], xy[:, 1]) bmap2.drawcoastlines(color=&amp;#39;gray&amp;#39;) bmap2.scatter(xx, yy, marker=&amp;#39;v&amp;#39;, s=150, facecolor=&amp;#39;#87CEFA&amp;#39;, edgecolor=&amp;#39;k&amp;#39;, lw=1, alpha=1) bmap2.drawmeridians(meridians=np.linspace(100, 110, 6), labels=[0, 0, 0, 1], color=&amp;#39;none&amp;#39;, fontsize=13) bmap2.drawparallels(circles=np.linspace(30, 40, 6), labels=[1, 0, 0, 0], color=&amp;#39;none&amp;#39;, fontsize=13) plt.show() It is worth noting that we compute the beam power in Cartesian coordinate system while we only have the longitudes and latitudes of these stations. Thus, we have to convert these longitudes and latitudes to Cartesian coordinates, so we define the following useful functions.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def distance(la1, lo1, LA2, LO2, R=6371): d2r = np.pi / 180 dla = (LA2-la1) * d2r dlo = (LO2-lo1) * d2r a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2 c = 2 * np.arctan2(a**0.5, (1-a)**0.5) return R * c * 1e3 def azimuth(la1, lo1, LA2, LO2): d2r = np.pi / 180 dla = (LA2 - la1) * d2r dlo = (LO2 - lo1) * d2r y = np.sin(dlo) * np.cos(LA2*d2r) x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo) th = np.arctan2(y, x) return (th / d2r &#43; 360) % 360 def lola2xy(xy): n = xy.shape[0] lo0 = xy[:, 0].mean() la0 = xy[:, 1].mean() dist = distance(la0, lo0, xy[:, 1], xy[:, 0]) az = azimuth(la0, lo0, xy[:, 1], xy[:, 0]) * np.pi / 180 new_xy = np.zeros_like(xy) new_xy[:, 0] = np.sin(az) * dist new_xy[:, 1] = np.cos(az) * dist return new_xy def process_data(d, operator, p=0.01): nd = len(d) pn = int(nd*p) h = hann(2*pn) d -= d.mean() d[:pn] *= h[:pn] d[-pn:] *= h[-pn] fd = np.fft.fft(d) fd /= np.convolve(np.abs(fd), operator, &amp;#39;same&amp;#39;) fd[np.isnan(fd)] = 0. return fd We need to estimate the average cross-spectral matrix of seismic data by this array before compute the beam power.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 st = read(&amp;#39;2008-03-10/*BHZ.SAC&amp;#39;) utcb = st[0].stats.starttime utce = st[0].stats.endtime dt = st[0].stats.delta; fs = 1 / dt xy = [] for tr in st: if utcb &amp;gt; tr.stats.starttime: utcb = tr.stats.starttime if utce &amp;lt; tr.stats.endtime: utce = tr.stats.endtime xy.append(sta[tr.stats.station]) xy = np.array(xy) xy = lola2xy(xy) n = xy.shape[0] nd = int((utce-utcb)/dt) data = np.zeros((n, nd&#43;50)) for ti, tr in enumerate(st): n0 = int((tr.stats.starttime-utcb)/dt) data[ti, n0: n0&#43;tr.stats.npts] = tr.data pt = 3600; pn = int(pt/dt); on = pn // 2 hn = 15; operator = np.ones(hn*2&#43;1) / (hn*2&#43;1) tmp_data = [] n1 = 0 while n1 &amp;lt; data.shape[1]-pn: tmp = [] n2 = n1 &#43; pn for i in range(n): tmp.append(process_data(data[i, n1:n2], operator)) tmp_data.append(tmp) n1 &#43;= on tmp_data = np.array(tmp_data) f1 = 1 / 9; f2 = 1 / 5 fn1 = int(f1*pn/fs); fn2 = int(f2*pn/fs); nf = fn2 - fn1 &#43;1 c = np.zeros((nf, n, n), dtype=complex) u = np.zeros((n, 1), dtype=complex) for i in range(fn1, fn2&#43;1): for j in range(tmp_data.shape[0]): u[:, 0] = tmp_data[j, :, i] c[i-fn1] &#43;= u @ np.conjugate(u.T) Now we compute the beam power using formula $(1)$ to estimate the back-azmith and corresponding ray parameter of the potential body wave.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 s1 = 0; s2 = 10; ns = 101 g = 111194.92664455 s = np.linspace(s1, s2, ns) / g b1 = 0; b2 = 360; nb = 181 b = np.linspace(b1, b2, nb) / 180 * np.pi p1 = np.zeros((ns, nb), dtype=complex) a = np.zeros((n, 1), dtype=complex) for i in range(ns): for j in range(nb): shift = -s[i] * (np.sin(b[j])*xy[:, 0] &#43; np.cos(b[j])*xy[:, 1]) for k in range(fn1, fn2&#43;1): w = 2 * np.pi * k * fs / pn a[:, 0] = np.exp(-1j*w*shift) cc = c[k-fn1].copy(); cc /= np.abs(cc); cc[np.isnan(cc)] = 0. p1[i, j] &#43;= np.conjugate(a.T) @ cc @ a p1 = np.abs(p1) / nf / n**2 Someone may find that we normalize the beam power using the number of frequency points and the number of stations, which results in the coherence of signals caught by this array. The maximum of backazimuth-slowness beam coherence panel suggests that the signal source comes from the direction ranging 315-360 degress with horizonral slowness ranging 4-6 sec/degree, and thus we identify this seismic phase as P wave. We calculate the ray parameter of P wave using the taup module, and the slowness-distance curve is shown by the following figure.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 model = TauPyModel(model=&amp;#39;iasp91&amp;#39;) dd = 0.02 d = np.arange(0, 95&#43;dd, dd) pw = np.zeros((len(d), 2)) phase = [&amp;#39;P&amp;#39;] for i in range(len(d)): ar = model.get_travel_times(source_depth_in_km=0, distance_in_degree=d[i], phase_list=phase) pw[i] = np.array([d[i], ar[0].ray_param]) pw[:, 1] = pw[:, 1] * np.pi / 180 plt.figure(figsize=(8, 4)) plt.plot(pw[:, 0], pw[:, 1], lw=2.5, color=&amp;#39;#00BFFF&amp;#39;) plt.xlabel(&amp;#39;Distance (degree)&amp;#39;, fontsize=18) plt.ylabel(&amp;#39;Ray parameter (sec/degree)&amp;#39;, fontsize=18) plt.gca().tick_params(labelsize=15) plt.xlim(30, 95) plt.ylim(4, 10) plt.grid(ls=(10, (6, 5))) plt.title(&amp;#39;Ray parameter of seismic phase P&amp;#39;, fontsize=17) plt.show() According to the beam coherence and the slowness-distance curve of P wave, we estimate that the distance between the source location the seismic array center is about 70 degrees. We utilize grid-searching rule to find the source location by projecting the backazimuth-slowness beam coherence to geographical coordinates.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def distance_matrix(la1, lo1, LA2, LO2): d2r = np.pi / 180 dla = (LA2-la1) * d2r dlo = (LO2-lo1) * d2r a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2 c = 2 * np.arctan2(a**0.5, (1-a)**0.5) return c * 180 / np.pi def azimuth_matrix(la1, lo1, LA2, LO2): d2r = np.pi / 180 dla = (LA2 - la1) * d2r dlo = (LO2 - lo1) * d2r y = np.sin(dlo) * np.cos(LA2*d2r) x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo) th = np.arctan2(y, x) return (th / d2r &#43; 360) % 360 xy = [] for tr in st: xy.append(sta[tr.stats.station]) xy = np.array(xy) lo0 = xy[:, 0].mean() la0 = xy[:, 1].mean() ns, nb = p1.shape ss = np.linspace(0, 10, ns) bb = np.linspace(0, 360, nb) ds = ss[1] - ss[0] db = bb[1] - bb[0] lo1 = -180; lo2 = 180; nlo = 181 la1 = -90; la2 = 90; nla = 91 lo = np.linspace(lo1, lo2, nlo) la = np.linspace(la1, la2, nla) LO, LA = np.meshgrid(lo, la) AZ = azimuth_matrix(la0, lo0, LA, LO) DIST = distance_matrix(la0, lo0, LA, LO) bp = np.zeros((nla, nlo)) for i in range(nla): for j in range(nlo): index = np.argmin(np.abs(DIST[i, j]-pw[:, 0])) if np.abs(DIST[i, j]-pw[index, 0]) &amp;gt; 0.05 or pw[index, 1] &amp;gt; ss.max(): continue si = int((pw[index, 1]-ss.min())/ds) ai = int((AZ[i, j]-bb.min())/db) bp[i, j] = p1[si, ai] plt.figure(figsize=(12, 6)) bmap = Basemap(projection=&amp;#39;cyl&amp;#39;, lon_0=0) plt.contourf(LO, LA, bp, cmap=cmap, levels=101) cbar = plt.colorbar(shrink=0.8) cbar.ax.tick_params(labelsize=15) cbar.set_label(&amp;#39;Cohenrence&amp;#39;, fontsize=15) bmap.fillcontinents(color=&amp;#39;#3CB371&amp;#39;) bmap.drawcoastlines(linewidth=0.3, color=&amp;#39;gray&amp;#39;) xx, yy = bmap(lo0, la0) bmap.scatter(xx, yy, marker=&amp;#39;v&amp;#39;, s=150, facecolor=&amp;#39;b&amp;#39;, alpha=0.6, zorder=2) bmap.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], fontsize=17, color=&amp;#39;none&amp;#39;) bmap.drawmeridians(meridians=np.linspace(-180, 180, 9), labels=[0, 0, 0, 1], fontsize=17, color=&amp;#39;none&amp;#39;) plt.show() This back-projection result shows that the possible source location is in the North Atlantic Ocean, which may relate to the irregular topography of the middle ocean rige in this place.
Perspective We use this simple example to explain the process of using body waves from ambient noise cross-correlations to investigate the potential source locations of these indentified seismic phases. Indeed, it still holds many mysteries to reveal in the seismic ambient noise world. Thus, we will continue the journey of exploring the coupling process among the atmosphere, oceans and our solid planet Earth.
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.109.0 with theme even" />


<link rel="canonical" href="https://geophydog.cool/post/noise_body_wave_source/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.2d16330b9b808f2827fb80842f1fb7be07dda2fe3a6fd081efdf06311b0a2c9a.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Locating Microseismic Body Wave Sources from Noise Cross-correlation" />
<meta property="og:description" content="Short background
Ambient noise tomography of regional and continental scales is much benefited from
the system composed of the atmosphere, ocean and the solid earth. Ambient noise below
1Hz is largely due to oceans, and interactions between ocean waves and/or the sea floor
generate pressure impulse propagating into the solid earth. Land seismic stations are seizing
seismic waves which originating from microseisms, and these seismic waves include surface waves
and body waves. Individuals can easily retrieve surface waves from ambient noise cross-correlations.
Body wave extraction from ambient noise, however, remains difficult. We often explore body waves from
ambient noise using array stacking techniques for array stacking leads to high signal-to-noise ratios.
Here we perform the body wave source location utilizing beamforming and back-projection methods,
and we process one-day seismic recordings by a seismic array in China, which reveals that the source location
is in the North Atlantic Ocean, the south of Iceland.
Data and Methods
We collect one-day continuous seismic data of vertical component(here BHZ, 2008-03-10) recorded by a seismic array nearly in
the center part of China (see the following figure), and compute the cross-spectral matrix using one-hour length
segment with a overlap of 50% (1800 seconds):
$$
C(\omega) = \frac{1}{N}\sum_{n=1}^N\boldsymbol{u}_n(\omega) \cdot \boldsymbol{u}_n^H(\omega), \tag{1}
$$
in which, $\boldsymbol{u}_n(\omega)=[u^1_n(\omega), u^2_n(\omega), \cdots, u^M_n]^T$ is the Fourier spectra
of the $n_{th}$ segment data recorded by $M$ stations, $H$ denotes Hermitian transpose, and $N$ is the total number of data segments.
Then we create steering vector as follows,
$$
\boldsymbol{a}(\omega; \boldsymbol{s}, \boldsymbol{x}) = [e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_1}, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_2}, \cdots, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_M}]^T, \tag{2}
$$
where, $\boldsymbol{s}$ and $\boldsymbol{x}_m$ separately indicate horizontal slowness (ray parameter for body waves) and position of the $m_{th}$ station.
The beam power is given by
$$
B(\omega; \boldsymbol{s}) = \boldsymbol{a}^H \boldsymbol{C}(\omega) \boldsymbol{a}. \tag{3}
$$
For more details about beamforming, someone can refer to this blog.
An Example of Locating the distant P wave source
We first import required Python libraries.


1
2
3
4
5
6
7
8


import numpy as np
import matplotlib.pyplot as plt
from obspy import read
from glob import glob
from mpl_toolkits.basemap import Basemap
from scipy.signal.windows import hann
import matplotlib as mpl
from obspy.taup import TauPyModel


The 13 seismic stations are installed in the center part of China, and we collect the data of March 10, 2008 to perform this work.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35


files = sorted(glob(&#39;2008-03-10/*BHZ.SAC&#39;))
sta = {}
with open(&#39;X4_IRIS_BHZ.txt&#39;, &#39;r&#39;) as fin:
    for line in fin.readlines():
        tmp = line.strip().split(&#39;|&#39;)
        sta[tmp[1]] = [float(tmp[3]), float(tmp[2])]
xy = []        
for f in files:
    tmp = f.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[1]
    xy.append(sta[tmp])
xy = np.array(xy)

plt.figure(figsize=(12, 4.5))
plt.subplot2grid((1, 3), (0, 0), rowspan=1, colspan=2)
bmap1 = Basemap(projection=&#39;cyl&#39;, lon_0=0)
bmap1.shadedrelief(scale=0.2)
xx, yy = bmap1(106, 34)
bmap1.scatter(xx, yy, marker=&#39;v&#39;, s=200, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap1.drawmeridians(meridians=np.linspace(-180, 180, 7),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=17)
bmap1.drawparallels(circles=np.linspace(-90, 90, 7),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=17)

plt.subplot2grid((1, 3), (0, 2), rowspan=1, colspan=1)
bmap2 = Basemap(projection=&#39;merc&#39;, llcrnrlat=30, llcrnrlon=100,
              urcrnrlon=110, urcrnrlat=39)
bmap2.shadedrelief(scale=1)
xx, yy = bmap2(xy[:, 0], xy[:, 1])
bmap2.drawcoastlines(color=&#39;gray&#39;)
bmap2.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap2.drawmeridians(meridians=np.linspace(100, 110, 6),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=13)
bmap2.drawparallels(circles=np.linspace(30, 40, 6),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=13)
plt.show()



It is worth noting that we compute the beam power in Cartesian coordinate system while we only have the longitudes and latitudes of these stations.
Thus, we have to convert these longitudes and latitudes to Cartesian coordinates, so we define the following useful functions.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


def distance(la1, lo1, LA2, LO2, R=6371):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return R * c * 1e3

def azimuth(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

def lola2xy(xy):
    n = xy.shape[0]
    lo0 = xy[:, 0].mean()
    la0 = xy[:, 1].mean()
    dist = distance(la0, lo0, xy[:, 1], xy[:, 0])
    az = azimuth(la0, lo0, xy[:, 1], xy[:, 0]) * np.pi / 180
    new_xy = np.zeros_like(xy)
    new_xy[:, 0] = np.sin(az) * dist
    new_xy[:, 1] = np.cos(az) * dist
    return new_xy
def process_data(d, operator, p=0.01):
    nd = len(d)
    pn = int(nd*p)
    h = hann(2*pn)
    d -= d.mean()
    d[:pn] *= h[:pn]
    d[-pn:] *= h[-pn]
    fd = np.fft.fft(d)
    fd /= np.convolve(np.abs(fd), operator, &#39;same&#39;)
    fd[np.isnan(fd)] = 0.
    return fd


We need to estimate the average cross-spectral matrix of seismic data by this array before compute the beam power.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


st = read(&#39;2008-03-10/*BHZ.SAC&#39;)
utcb = st[0].stats.starttime
utce = st[0].stats.endtime
dt = st[0].stats.delta; fs = 1 / dt
xy = []
for tr in st:
    if utcb &gt; tr.stats.starttime:
        utcb = tr.stats.starttime
    if utce &lt; tr.stats.endtime:
        utce = tr.stats.endtime
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
xy = lola2xy(xy)
n = xy.shape[0]
nd = int((utce-utcb)/dt)
data = np.zeros((n, nd&#43;50))
for ti, tr in enumerate(st):
    n0 = int((tr.stats.starttime-utcb)/dt)
    data[ti, n0: n0&#43;tr.stats.npts] = tr.data

pt = 3600; pn = int(pt/dt); on = pn // 2
hn = 15; operator = np.ones(hn*2&#43;1) / (hn*2&#43;1)
tmp_data = []
n1 = 0
while n1 &lt; data.shape[1]-pn:
    tmp = []
    n2 = n1 &#43; pn
    for i in range(n):
        tmp.append(process_data(data[i, n1:n2], operator))
    tmp_data.append(tmp)
    n1 &#43;= on
tmp_data = np.array(tmp_data)
f1 = 1 / 9; f2 = 1 / 5
fn1 = int(f1*pn/fs); fn2 = int(f2*pn/fs); nf = fn2 - fn1 &#43;1
c = np.zeros((nf, n, n), dtype=complex)
u = np.zeros((n, 1), dtype=complex)
for i in range(fn1, fn2&#43;1):
    for j in range(tmp_data.shape[0]):
        u[:, 0] = tmp_data[j, :, i]
        c[i-fn1] &#43;= u @ np.conjugate(u.T)


Now we compute the beam power using formula $(1)$ to estimate the back-azmith and corresponding ray parameter of the potential body wave.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


s1 = 0; s2 = 10; ns = 101
g = 111194.92664455
s = np.linspace(s1, s2, ns) / g
b1 = 0; b2 = 360; nb = 181
b = np.linspace(b1, b2, nb) / 180 * np.pi
p1 = np.zeros((ns, nb), dtype=complex)
a = np.zeros((n, 1), dtype=complex)
for i in range(ns):
    for j in range(nb):
        shift = -s[i] * (np.sin(b[j])*xy[:, 0] &#43; np.cos(b[j])*xy[:, 1])
        for k in range(fn1, fn2&#43;1):
            w = 2 * np.pi * k * fs / pn
            a[:, 0] = np.exp(-1j*w*shift)
            cc = c[k-fn1].copy(); cc /= np.abs(cc); cc[np.isnan(cc)] = 0.
            p1[i, j] &#43;= np.conjugate(a.T) @ cc @ a
p1 = np.abs(p1) / nf / n**2


Someone may find that we normalize the beam power using the number of frequency points and the number of stations, which results in
the coherence of signals caught by this array.

The maximum of backazimuth-slowness beam coherence panel suggests that the signal source comes from the direction ranging 315-360 degress with horizonral slowness ranging 4-6 sec/degree, and thus we identify this seismic phase as P wave. We calculate the ray parameter of P wave using the taup module, and the slowness-distance curve is shown by the following figure.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


model = TauPyModel(model=&#39;iasp91&#39;)
dd = 0.02
d = np.arange(0, 95&#43;dd, dd)
pw = np.zeros((len(d), 2))
phase = [&#39;P&#39;]
for i in range(len(d)):
    ar = model.get_travel_times(source_depth_in_km=0,
                                  distance_in_degree=d[i],
                               phase_list=phase)
    pw[i] = np.array([d[i], ar[0].ray_param])
pw[:, 1] = pw[:, 1] * np.pi / 180

plt.figure(figsize=(8, 4))
plt.plot(pw[:, 0], pw[:, 1], lw=2.5, color=&#39;#00BFFF&#39;)
plt.xlabel(&#39;Distance (degree)&#39;, fontsize=18)
plt.ylabel(&#39;Ray parameter (sec/degree)&#39;, fontsize=18)
plt.gca().tick_params(labelsize=15)
plt.xlim(30, 95)
plt.ylim(4, 10)
plt.grid(ls=(10, (6, 5)))
plt.title(&#39;Ray parameter of seismic phase P&#39;, fontsize=17)
plt.show()



According to the beam coherence and the slowness-distance curve of P wave, we estimate that the distance between the source location the seismic array center is about 70 degrees. We utilize grid-searching rule to find the source location by projecting the backazimuth-slowness beam coherence to geographical coordinates.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58


def distance_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return c * 180 / np.pi

def azimuth_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

xy = []
for tr in st:
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
lo0 = xy[:, 0].mean()
la0 = xy[:, 1].mean()
ns, nb = p1.shape
ss = np.linspace(0, 10, ns)
bb = np.linspace(0, 360, nb)
ds = ss[1] - ss[0]
db = bb[1] - bb[0]
lo1 = -180; lo2 = 180; nlo = 181
la1 = -90; la2 = 90; nla = 91
lo = np.linspace(lo1, lo2, nlo)
la = np.linspace(la1, la2, nla)
LO, LA = np.meshgrid(lo, la)
AZ = azimuth_matrix(la0, lo0, LA, LO)
DIST = distance_matrix(la0, lo0, LA, LO)
bp = np.zeros((nla, nlo))
for i in range(nla):
    for j in range(nlo):
        index = np.argmin(np.abs(DIST[i, j]-pw[:, 0]))
        if np.abs(DIST[i, j]-pw[index, 0]) &gt; 0.05 or pw[index, 1] &gt; ss.max():
            continue
        si = int((pw[index, 1]-ss.min())/ds)
        ai = int((AZ[i, j]-bb.min())/db)
        bp[i, j] = p1[si, ai]

plt.figure(figsize=(12, 6))
bmap = Basemap(projection=&#39;cyl&#39;, lon_0=0)
plt.contourf(LO, LA, bp, cmap=cmap, levels=101)
cbar = plt.colorbar(shrink=0.8)
cbar.ax.tick_params(labelsize=15)
cbar.set_label(&#39;Cohenrence&#39;, fontsize=15)
bmap.fillcontinents(color=&#39;#3CB371&#39;)
bmap.drawcoastlines(linewidth=0.3, color=&#39;gray&#39;)
xx, yy = bmap(lo0, la0)
bmap.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;b&#39;, alpha=0.6, zorder=2)
bmap.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], fontsize=17, color=&#39;none&#39;)
bmap.drawmeridians(meridians=np.linspace(-180, 180, 9), labels=[0, 0, 0, 1], fontsize=17, color=&#39;none&#39;)
plt.show()



This back-projection result shows that the possible source location is in the North Atlantic Ocean, which may relate to the irregular topography of the middle ocean rige in this place.
Perspective
We use this simple example to explain the process of using body waves from ambient noise cross-correlations to investigate the potential source locations of these indentified seismic phases. Indeed, it still holds many mysteries to reveal in the seismic ambient noise world. Thus, we will continue the journey of exploring the coupling process among the atmosphere, oceans and our solid planet Earth.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://geophydog.cool/post/noise_body_wave_source/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-01-10T18:49:53+08:00" />
<meta property="article:modified_time" content="2023-01-10T18:49:53+08:00" />
<meta itemprop="name" content="Locating Microseismic Body Wave Sources from Noise Cross-correlation">
<meta itemprop="description" content="Short background
Ambient noise tomography of regional and continental scales is much benefited from
the system composed of the atmosphere, ocean and the solid earth. Ambient noise below
1Hz is largely due to oceans, and interactions between ocean waves and/or the sea floor
generate pressure impulse propagating into the solid earth. Land seismic stations are seizing
seismic waves which originating from microseisms, and these seismic waves include surface waves
and body waves. Individuals can easily retrieve surface waves from ambient noise cross-correlations.
Body wave extraction from ambient noise, however, remains difficult. We often explore body waves from
ambient noise using array stacking techniques for array stacking leads to high signal-to-noise ratios.
Here we perform the body wave source location utilizing beamforming and back-projection methods,
and we process one-day seismic recordings by a seismic array in China, which reveals that the source location
is in the North Atlantic Ocean, the south of Iceland.
Data and Methods
We collect one-day continuous seismic data of vertical component(here BHZ, 2008-03-10) recorded by a seismic array nearly in
the center part of China (see the following figure), and compute the cross-spectral matrix using one-hour length
segment with a overlap of 50% (1800 seconds):
$$
C(\omega) = \frac{1}{N}\sum_{n=1}^N\boldsymbol{u}_n(\omega) \cdot \boldsymbol{u}_n^H(\omega), \tag{1}
$$
in which, $\boldsymbol{u}_n(\omega)=[u^1_n(\omega), u^2_n(\omega), \cdots, u^M_n]^T$ is the Fourier spectra
of the $n_{th}$ segment data recorded by $M$ stations, $H$ denotes Hermitian transpose, and $N$ is the total number of data segments.
Then we create steering vector as follows,
$$
\boldsymbol{a}(\omega; \boldsymbol{s}, \boldsymbol{x}) = [e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_1}, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_2}, \cdots, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_M}]^T, \tag{2}
$$
where, $\boldsymbol{s}$ and $\boldsymbol{x}_m$ separately indicate horizontal slowness (ray parameter for body waves) and position of the $m_{th}$ station.
The beam power is given by
$$
B(\omega; \boldsymbol{s}) = \boldsymbol{a}^H \boldsymbol{C}(\omega) \boldsymbol{a}. \tag{3}
$$
For more details about beamforming, someone can refer to this blog.
An Example of Locating the distant P wave source
We first import required Python libraries.


1
2
3
4
5
6
7
8


import numpy as np
import matplotlib.pyplot as plt
from obspy import read
from glob import glob
from mpl_toolkits.basemap import Basemap
from scipy.signal.windows import hann
import matplotlib as mpl
from obspy.taup import TauPyModel


The 13 seismic stations are installed in the center part of China, and we collect the data of March 10, 2008 to perform this work.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35


files = sorted(glob(&#39;2008-03-10/*BHZ.SAC&#39;))
sta = {}
with open(&#39;X4_IRIS_BHZ.txt&#39;, &#39;r&#39;) as fin:
    for line in fin.readlines():
        tmp = line.strip().split(&#39;|&#39;)
        sta[tmp[1]] = [float(tmp[3]), float(tmp[2])]
xy = []        
for f in files:
    tmp = f.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[1]
    xy.append(sta[tmp])
xy = np.array(xy)

plt.figure(figsize=(12, 4.5))
plt.subplot2grid((1, 3), (0, 0), rowspan=1, colspan=2)
bmap1 = Basemap(projection=&#39;cyl&#39;, lon_0=0)
bmap1.shadedrelief(scale=0.2)
xx, yy = bmap1(106, 34)
bmap1.scatter(xx, yy, marker=&#39;v&#39;, s=200, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap1.drawmeridians(meridians=np.linspace(-180, 180, 7),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=17)
bmap1.drawparallels(circles=np.linspace(-90, 90, 7),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=17)

plt.subplot2grid((1, 3), (0, 2), rowspan=1, colspan=1)
bmap2 = Basemap(projection=&#39;merc&#39;, llcrnrlat=30, llcrnrlon=100,
              urcrnrlon=110, urcrnrlat=39)
bmap2.shadedrelief(scale=1)
xx, yy = bmap2(xy[:, 0], xy[:, 1])
bmap2.drawcoastlines(color=&#39;gray&#39;)
bmap2.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap2.drawmeridians(meridians=np.linspace(100, 110, 6),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=13)
bmap2.drawparallels(circles=np.linspace(30, 40, 6),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=13)
plt.show()



It is worth noting that we compute the beam power in Cartesian coordinate system while we only have the longitudes and latitudes of these stations.
Thus, we have to convert these longitudes and latitudes to Cartesian coordinates, so we define the following useful functions.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


def distance(la1, lo1, LA2, LO2, R=6371):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return R * c * 1e3

def azimuth(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

def lola2xy(xy):
    n = xy.shape[0]
    lo0 = xy[:, 0].mean()
    la0 = xy[:, 1].mean()
    dist = distance(la0, lo0, xy[:, 1], xy[:, 0])
    az = azimuth(la0, lo0, xy[:, 1], xy[:, 0]) * np.pi / 180
    new_xy = np.zeros_like(xy)
    new_xy[:, 0] = np.sin(az) * dist
    new_xy[:, 1] = np.cos(az) * dist
    return new_xy
def process_data(d, operator, p=0.01):
    nd = len(d)
    pn = int(nd*p)
    h = hann(2*pn)
    d -= d.mean()
    d[:pn] *= h[:pn]
    d[-pn:] *= h[-pn]
    fd = np.fft.fft(d)
    fd /= np.convolve(np.abs(fd), operator, &#39;same&#39;)
    fd[np.isnan(fd)] = 0.
    return fd


We need to estimate the average cross-spectral matrix of seismic data by this array before compute the beam power.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


st = read(&#39;2008-03-10/*BHZ.SAC&#39;)
utcb = st[0].stats.starttime
utce = st[0].stats.endtime
dt = st[0].stats.delta; fs = 1 / dt
xy = []
for tr in st:
    if utcb &gt; tr.stats.starttime:
        utcb = tr.stats.starttime
    if utce &lt; tr.stats.endtime:
        utce = tr.stats.endtime
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
xy = lola2xy(xy)
n = xy.shape[0]
nd = int((utce-utcb)/dt)
data = np.zeros((n, nd&#43;50))
for ti, tr in enumerate(st):
    n0 = int((tr.stats.starttime-utcb)/dt)
    data[ti, n0: n0&#43;tr.stats.npts] = tr.data

pt = 3600; pn = int(pt/dt); on = pn // 2
hn = 15; operator = np.ones(hn*2&#43;1) / (hn*2&#43;1)
tmp_data = []
n1 = 0
while n1 &lt; data.shape[1]-pn:
    tmp = []
    n2 = n1 &#43; pn
    for i in range(n):
        tmp.append(process_data(data[i, n1:n2], operator))
    tmp_data.append(tmp)
    n1 &#43;= on
tmp_data = np.array(tmp_data)
f1 = 1 / 9; f2 = 1 / 5
fn1 = int(f1*pn/fs); fn2 = int(f2*pn/fs); nf = fn2 - fn1 &#43;1
c = np.zeros((nf, n, n), dtype=complex)
u = np.zeros((n, 1), dtype=complex)
for i in range(fn1, fn2&#43;1):
    for j in range(tmp_data.shape[0]):
        u[:, 0] = tmp_data[j, :, i]
        c[i-fn1] &#43;= u @ np.conjugate(u.T)


Now we compute the beam power using formula $(1)$ to estimate the back-azmith and corresponding ray parameter of the potential body wave.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


s1 = 0; s2 = 10; ns = 101
g = 111194.92664455
s = np.linspace(s1, s2, ns) / g
b1 = 0; b2 = 360; nb = 181
b = np.linspace(b1, b2, nb) / 180 * np.pi
p1 = np.zeros((ns, nb), dtype=complex)
a = np.zeros((n, 1), dtype=complex)
for i in range(ns):
    for j in range(nb):
        shift = -s[i] * (np.sin(b[j])*xy[:, 0] &#43; np.cos(b[j])*xy[:, 1])
        for k in range(fn1, fn2&#43;1):
            w = 2 * np.pi * k * fs / pn
            a[:, 0] = np.exp(-1j*w*shift)
            cc = c[k-fn1].copy(); cc /= np.abs(cc); cc[np.isnan(cc)] = 0.
            p1[i, j] &#43;= np.conjugate(a.T) @ cc @ a
p1 = np.abs(p1) / nf / n**2


Someone may find that we normalize the beam power using the number of frequency points and the number of stations, which results in
the coherence of signals caught by this array.

The maximum of backazimuth-slowness beam coherence panel suggests that the signal source comes from the direction ranging 315-360 degress with horizonral slowness ranging 4-6 sec/degree, and thus we identify this seismic phase as P wave. We calculate the ray parameter of P wave using the taup module, and the slowness-distance curve is shown by the following figure.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


model = TauPyModel(model=&#39;iasp91&#39;)
dd = 0.02
d = np.arange(0, 95&#43;dd, dd)
pw = np.zeros((len(d), 2))
phase = [&#39;P&#39;]
for i in range(len(d)):
    ar = model.get_travel_times(source_depth_in_km=0,
                                  distance_in_degree=d[i],
                               phase_list=phase)
    pw[i] = np.array([d[i], ar[0].ray_param])
pw[:, 1] = pw[:, 1] * np.pi / 180

plt.figure(figsize=(8, 4))
plt.plot(pw[:, 0], pw[:, 1], lw=2.5, color=&#39;#00BFFF&#39;)
plt.xlabel(&#39;Distance (degree)&#39;, fontsize=18)
plt.ylabel(&#39;Ray parameter (sec/degree)&#39;, fontsize=18)
plt.gca().tick_params(labelsize=15)
plt.xlim(30, 95)
plt.ylim(4, 10)
plt.grid(ls=(10, (6, 5)))
plt.title(&#39;Ray parameter of seismic phase P&#39;, fontsize=17)
plt.show()



According to the beam coherence and the slowness-distance curve of P wave, we estimate that the distance between the source location the seismic array center is about 70 degrees. We utilize grid-searching rule to find the source location by projecting the backazimuth-slowness beam coherence to geographical coordinates.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58


def distance_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return c * 180 / np.pi

def azimuth_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

xy = []
for tr in st:
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
lo0 = xy[:, 0].mean()
la0 = xy[:, 1].mean()
ns, nb = p1.shape
ss = np.linspace(0, 10, ns)
bb = np.linspace(0, 360, nb)
ds = ss[1] - ss[0]
db = bb[1] - bb[0]
lo1 = -180; lo2 = 180; nlo = 181
la1 = -90; la2 = 90; nla = 91
lo = np.linspace(lo1, lo2, nlo)
la = np.linspace(la1, la2, nla)
LO, LA = np.meshgrid(lo, la)
AZ = azimuth_matrix(la0, lo0, LA, LO)
DIST = distance_matrix(la0, lo0, LA, LO)
bp = np.zeros((nla, nlo))
for i in range(nla):
    for j in range(nlo):
        index = np.argmin(np.abs(DIST[i, j]-pw[:, 0]))
        if np.abs(DIST[i, j]-pw[index, 0]) &gt; 0.05 or pw[index, 1] &gt; ss.max():
            continue
        si = int((pw[index, 1]-ss.min())/ds)
        ai = int((AZ[i, j]-bb.min())/db)
        bp[i, j] = p1[si, ai]

plt.figure(figsize=(12, 6))
bmap = Basemap(projection=&#39;cyl&#39;, lon_0=0)
plt.contourf(LO, LA, bp, cmap=cmap, levels=101)
cbar = plt.colorbar(shrink=0.8)
cbar.ax.tick_params(labelsize=15)
cbar.set_label(&#39;Cohenrence&#39;, fontsize=15)
bmap.fillcontinents(color=&#39;#3CB371&#39;)
bmap.drawcoastlines(linewidth=0.3, color=&#39;gray&#39;)
xx, yy = bmap(lo0, la0)
bmap.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;b&#39;, alpha=0.6, zorder=2)
bmap.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], fontsize=17, color=&#39;none&#39;)
bmap.drawmeridians(meridians=np.linspace(-180, 180, 9), labels=[0, 0, 0, 1], fontsize=17, color=&#39;none&#39;)
plt.show()



This back-projection result shows that the possible source location is in the North Atlantic Ocean, which may relate to the irregular topography of the middle ocean rige in this place.
Perspective
We use this simple example to explain the process of using body waves from ambient noise cross-correlations to investigate the potential source locations of these indentified seismic phases. Indeed, it still holds many mysteries to reveal in the seismic ambient noise world. Thus, we will continue the journey of exploring the coupling process among the atmosphere, oceans and our solid planet Earth.
"><meta itemprop="datePublished" content="2023-01-10T18:49:53+08:00" />
<meta itemprop="dateModified" content="2023-01-10T18:49:53+08:00" />
<meta itemprop="wordCount" content="1853">
<meta itemprop="keywords" content="beamforming,body wave,source-location,ambient noise," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Locating Microseismic Body Wave Sources from Noise Cross-correlation"/>
<meta name="twitter:description" content="Short background
Ambient noise tomography of regional and continental scales is much benefited from
the system composed of the atmosphere, ocean and the solid earth. Ambient noise below
1Hz is largely due to oceans, and interactions between ocean waves and/or the sea floor
generate pressure impulse propagating into the solid earth. Land seismic stations are seizing
seismic waves which originating from microseisms, and these seismic waves include surface waves
and body waves. Individuals can easily retrieve surface waves from ambient noise cross-correlations.
Body wave extraction from ambient noise, however, remains difficult. We often explore body waves from
ambient noise using array stacking techniques for array stacking leads to high signal-to-noise ratios.
Here we perform the body wave source location utilizing beamforming and back-projection methods,
and we process one-day seismic recordings by a seismic array in China, which reveals that the source location
is in the North Atlantic Ocean, the south of Iceland.
Data and Methods
We collect one-day continuous seismic data of vertical component(here BHZ, 2008-03-10) recorded by a seismic array nearly in
the center part of China (see the following figure), and compute the cross-spectral matrix using one-hour length
segment with a overlap of 50% (1800 seconds):
$$
C(\omega) = \frac{1}{N}\sum_{n=1}^N\boldsymbol{u}_n(\omega) \cdot \boldsymbol{u}_n^H(\omega), \tag{1}
$$
in which, $\boldsymbol{u}_n(\omega)=[u^1_n(\omega), u^2_n(\omega), \cdots, u^M_n]^T$ is the Fourier spectra
of the $n_{th}$ segment data recorded by $M$ stations, $H$ denotes Hermitian transpose, and $N$ is the total number of data segments.
Then we create steering vector as follows,
$$
\boldsymbol{a}(\omega; \boldsymbol{s}, \boldsymbol{x}) = [e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_1}, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_2}, \cdots, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_M}]^T, \tag{2}
$$
where, $\boldsymbol{s}$ and $\boldsymbol{x}_m$ separately indicate horizontal slowness (ray parameter for body waves) and position of the $m_{th}$ station.
The beam power is given by
$$
B(\omega; \boldsymbol{s}) = \boldsymbol{a}^H \boldsymbol{C}(\omega) \boldsymbol{a}. \tag{3}
$$
For more details about beamforming, someone can refer to this blog.
An Example of Locating the distant P wave source
We first import required Python libraries.


1
2
3
4
5
6
7
8


import numpy as np
import matplotlib.pyplot as plt
from obspy import read
from glob import glob
from mpl_toolkits.basemap import Basemap
from scipy.signal.windows import hann
import matplotlib as mpl
from obspy.taup import TauPyModel


The 13 seismic stations are installed in the center part of China, and we collect the data of March 10, 2008 to perform this work.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35


files = sorted(glob(&#39;2008-03-10/*BHZ.SAC&#39;))
sta = {}
with open(&#39;X4_IRIS_BHZ.txt&#39;, &#39;r&#39;) as fin:
    for line in fin.readlines():
        tmp = line.strip().split(&#39;|&#39;)
        sta[tmp[1]] = [float(tmp[3]), float(tmp[2])]
xy = []        
for f in files:
    tmp = f.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[1]
    xy.append(sta[tmp])
xy = np.array(xy)

plt.figure(figsize=(12, 4.5))
plt.subplot2grid((1, 3), (0, 0), rowspan=1, colspan=2)
bmap1 = Basemap(projection=&#39;cyl&#39;, lon_0=0)
bmap1.shadedrelief(scale=0.2)
xx, yy = bmap1(106, 34)
bmap1.scatter(xx, yy, marker=&#39;v&#39;, s=200, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap1.drawmeridians(meridians=np.linspace(-180, 180, 7),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=17)
bmap1.drawparallels(circles=np.linspace(-90, 90, 7),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=17)

plt.subplot2grid((1, 3), (0, 2), rowspan=1, colspan=1)
bmap2 = Basemap(projection=&#39;merc&#39;, llcrnrlat=30, llcrnrlon=100,
              urcrnrlon=110, urcrnrlat=39)
bmap2.shadedrelief(scale=1)
xx, yy = bmap2(xy[:, 0], xy[:, 1])
bmap2.drawcoastlines(color=&#39;gray&#39;)
bmap2.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;#87CEFA&#39;, edgecolor=&#39;k&#39;, lw=1, alpha=1)
bmap2.drawmeridians(meridians=np.linspace(100, 110, 6),
                  labels=[0, 0, 0, 1], color=&#39;none&#39;, fontsize=13)
bmap2.drawparallels(circles=np.linspace(30, 40, 6),
                  labels=[1, 0, 0, 0], color=&#39;none&#39;, fontsize=13)
plt.show()



It is worth noting that we compute the beam power in Cartesian coordinate system while we only have the longitudes and latitudes of these stations.
Thus, we have to convert these longitudes and latitudes to Cartesian coordinates, so we define the following useful functions.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


def distance(la1, lo1, LA2, LO2, R=6371):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return R * c * 1e3

def azimuth(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

def lola2xy(xy):
    n = xy.shape[0]
    lo0 = xy[:, 0].mean()
    la0 = xy[:, 1].mean()
    dist = distance(la0, lo0, xy[:, 1], xy[:, 0])
    az = azimuth(la0, lo0, xy[:, 1], xy[:, 0]) * np.pi / 180
    new_xy = np.zeros_like(xy)
    new_xy[:, 0] = np.sin(az) * dist
    new_xy[:, 1] = np.cos(az) * dist
    return new_xy
def process_data(d, operator, p=0.01):
    nd = len(d)
    pn = int(nd*p)
    h = hann(2*pn)
    d -= d.mean()
    d[:pn] *= h[:pn]
    d[-pn:] *= h[-pn]
    fd = np.fft.fft(d)
    fd /= np.convolve(np.abs(fd), operator, &#39;same&#39;)
    fd[np.isnan(fd)] = 0.
    return fd


We need to estimate the average cross-spectral matrix of seismic data by this array before compute the beam power.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


st = read(&#39;2008-03-10/*BHZ.SAC&#39;)
utcb = st[0].stats.starttime
utce = st[0].stats.endtime
dt = st[0].stats.delta; fs = 1 / dt
xy = []
for tr in st:
    if utcb &gt; tr.stats.starttime:
        utcb = tr.stats.starttime
    if utce &lt; tr.stats.endtime:
        utce = tr.stats.endtime
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
xy = lola2xy(xy)
n = xy.shape[0]
nd = int((utce-utcb)/dt)
data = np.zeros((n, nd&#43;50))
for ti, tr in enumerate(st):
    n0 = int((tr.stats.starttime-utcb)/dt)
    data[ti, n0: n0&#43;tr.stats.npts] = tr.data

pt = 3600; pn = int(pt/dt); on = pn // 2
hn = 15; operator = np.ones(hn*2&#43;1) / (hn*2&#43;1)
tmp_data = []
n1 = 0
while n1 &lt; data.shape[1]-pn:
    tmp = []
    n2 = n1 &#43; pn
    for i in range(n):
        tmp.append(process_data(data[i, n1:n2], operator))
    tmp_data.append(tmp)
    n1 &#43;= on
tmp_data = np.array(tmp_data)
f1 = 1 / 9; f2 = 1 / 5
fn1 = int(f1*pn/fs); fn2 = int(f2*pn/fs); nf = fn2 - fn1 &#43;1
c = np.zeros((nf, n, n), dtype=complex)
u = np.zeros((n, 1), dtype=complex)
for i in range(fn1, fn2&#43;1):
    for j in range(tmp_data.shape[0]):
        u[:, 0] = tmp_data[j, :, i]
        c[i-fn1] &#43;= u @ np.conjugate(u.T)


Now we compute the beam power using formula $(1)$ to estimate the back-azmith and corresponding ray parameter of the potential body wave.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


s1 = 0; s2 = 10; ns = 101
g = 111194.92664455
s = np.linspace(s1, s2, ns) / g
b1 = 0; b2 = 360; nb = 181
b = np.linspace(b1, b2, nb) / 180 * np.pi
p1 = np.zeros((ns, nb), dtype=complex)
a = np.zeros((n, 1), dtype=complex)
for i in range(ns):
    for j in range(nb):
        shift = -s[i] * (np.sin(b[j])*xy[:, 0] &#43; np.cos(b[j])*xy[:, 1])
        for k in range(fn1, fn2&#43;1):
            w = 2 * np.pi * k * fs / pn
            a[:, 0] = np.exp(-1j*w*shift)
            cc = c[k-fn1].copy(); cc /= np.abs(cc); cc[np.isnan(cc)] = 0.
            p1[i, j] &#43;= np.conjugate(a.T) @ cc @ a
p1 = np.abs(p1) / nf / n**2


Someone may find that we normalize the beam power using the number of frequency points and the number of stations, which results in
the coherence of signals caught by this array.

The maximum of backazimuth-slowness beam coherence panel suggests that the signal source comes from the direction ranging 315-360 degress with horizonral slowness ranging 4-6 sec/degree, and thus we identify this seismic phase as P wave. We calculate the ray parameter of P wave using the taup module, and the slowness-distance curve is shown by the following figure.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


model = TauPyModel(model=&#39;iasp91&#39;)
dd = 0.02
d = np.arange(0, 95&#43;dd, dd)
pw = np.zeros((len(d), 2))
phase = [&#39;P&#39;]
for i in range(len(d)):
    ar = model.get_travel_times(source_depth_in_km=0,
                                  distance_in_degree=d[i],
                               phase_list=phase)
    pw[i] = np.array([d[i], ar[0].ray_param])
pw[:, 1] = pw[:, 1] * np.pi / 180

plt.figure(figsize=(8, 4))
plt.plot(pw[:, 0], pw[:, 1], lw=2.5, color=&#39;#00BFFF&#39;)
plt.xlabel(&#39;Distance (degree)&#39;, fontsize=18)
plt.ylabel(&#39;Ray parameter (sec/degree)&#39;, fontsize=18)
plt.gca().tick_params(labelsize=15)
plt.xlim(30, 95)
plt.ylim(4, 10)
plt.grid(ls=(10, (6, 5)))
plt.title(&#39;Ray parameter of seismic phase P&#39;, fontsize=17)
plt.show()



According to the beam coherence and the slowness-distance curve of P wave, we estimate that the distance between the source location the seismic array center is about 70 degrees. We utilize grid-searching rule to find the source location by projecting the backazimuth-slowness beam coherence to geographical coordinates.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58


def distance_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2-la1) * d2r
    dlo = (LO2-lo1) * d2r
    a = np.sin(dla/2) ** 2 &#43; np.cos(la1*d2r) * np.cos(LA2*d2r) * np.sin(dlo/2) ** 2
    c = 2 * np.arctan2(a**0.5, (1-a)**0.5)
    return c * 180 / np.pi

def azimuth_matrix(la1, lo1, LA2, LO2):
    d2r = np.pi / 180
    dla = (LA2 - la1) * d2r
    dlo = (LO2 - lo1) * d2r
    y = np.sin(dlo) * np.cos(LA2*d2r)
    x = np.cos(la1*d2r) * np.sin(LA2*d2r) - np.sin(la1*d2r) * np.cos(LA2*d2r) * np.cos(dlo)
    th = np.arctan2(y, x)
    return (th / d2r &#43; 360) % 360

xy = []
for tr in st:
    xy.append(sta[tr.stats.station])
xy = np.array(xy)
lo0 = xy[:, 0].mean()
la0 = xy[:, 1].mean()
ns, nb = p1.shape
ss = np.linspace(0, 10, ns)
bb = np.linspace(0, 360, nb)
ds = ss[1] - ss[0]
db = bb[1] - bb[0]
lo1 = -180; lo2 = 180; nlo = 181
la1 = -90; la2 = 90; nla = 91
lo = np.linspace(lo1, lo2, nlo)
la = np.linspace(la1, la2, nla)
LO, LA = np.meshgrid(lo, la)
AZ = azimuth_matrix(la0, lo0, LA, LO)
DIST = distance_matrix(la0, lo0, LA, LO)
bp = np.zeros((nla, nlo))
for i in range(nla):
    for j in range(nlo):
        index = np.argmin(np.abs(DIST[i, j]-pw[:, 0]))
        if np.abs(DIST[i, j]-pw[index, 0]) &gt; 0.05 or pw[index, 1] &gt; ss.max():
            continue
        si = int((pw[index, 1]-ss.min())/ds)
        ai = int((AZ[i, j]-bb.min())/db)
        bp[i, j] = p1[si, ai]

plt.figure(figsize=(12, 6))
bmap = Basemap(projection=&#39;cyl&#39;, lon_0=0)
plt.contourf(LO, LA, bp, cmap=cmap, levels=101)
cbar = plt.colorbar(shrink=0.8)
cbar.ax.tick_params(labelsize=15)
cbar.set_label(&#39;Cohenrence&#39;, fontsize=15)
bmap.fillcontinents(color=&#39;#3CB371&#39;)
bmap.drawcoastlines(linewidth=0.3, color=&#39;gray&#39;)
xx, yy = bmap(lo0, la0)
bmap.scatter(xx, yy, marker=&#39;v&#39;, s=150, facecolor=&#39;b&#39;, alpha=0.6, zorder=2)
bmap.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], fontsize=17, color=&#39;none&#39;)
bmap.drawmeridians(meridians=np.linspace(-180, 180, 9), labels=[0, 0, 0, 1], fontsize=17, color=&#39;none&#39;)
plt.show()



This back-projection result shows that the possible source location is in the North Atlantic Ocean, which may relate to the irregular topography of the middle ocean rige in this place.
Perspective
We use this simple example to explain the process of using body waves from ambient noise cross-correlations to investigate the potential source locations of these indentified seismic phases. Indeed, it still holds many mysteries to reveal in the seismic ambient noise world. Thus, we will continue the journey of exploring the coupling process among the atmosphere, oceans and our solid planet Earth.
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Geophydog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/home">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/">
        <li class="mobile-menu-item">Blogs</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/tools/">
        <li class="mobile-menu-item">Tools</li>
      </a><a href="/post/about">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Geophydog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/home">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/">Blogs</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tools/">Tools</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/about">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Locating Microseismic Body Wave Sources from Noise Cross-correlation</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-01-10 </span>
        <div class="post-category">
            <a href="/categories/beamforming/"> beamforming </a>
            <a href="/categories/source-location/"> source-location </a>
            <a href="/categories/array-processing/"> array-processing </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#short-background">Short background</a></li>
            <li><a href="#data-and-methods">Data and Methods</a></li>
            <li><a href="#an-example-of-locating-the-distant-p-wave-source">An Example of Locating the distant P wave source</a></li>
            <li><a href="#perspective">Perspective</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h3 id="short-background">Short background</h3>
<p>Ambient noise tomography of regional and continental scales is much benefited from
the system composed of the atmosphere, ocean and the solid earth. Ambient noise below
1Hz is largely due to oceans, and interactions between ocean waves and/or the sea floor
generate pressure impulse propagating into the solid earth. Land seismic stations are seizing
seismic waves which originating from microseisms, and these seismic waves include surface waves
and body waves. Individuals can easily retrieve surface waves from ambient noise cross-correlations.
Body wave extraction from ambient noise, however, remains difficult. We often explore body waves from
ambient noise using array stacking techniques for array stacking leads to high signal-to-noise ratios.
Here we perform the body wave source location utilizing beamforming and back-projection methods,
and we process one-day seismic recordings by a seismic array in China, which reveals that the source location
is in the North Atlantic Ocean, the south of Iceland.</p>
<h3 id="data-and-methods">Data and Methods</h3>
<p>We collect one-day continuous seismic data of vertical component(here BHZ, 2008-03-10) recorded by a seismic array nearly in
the center part of China (see the following figure), and compute the cross-spectral matrix using one-hour length
segment with a overlap of 50% (1800 seconds):
$$
C(\omega) = \frac{1}{N}\sum_{n=1}^N\boldsymbol{u}_n(\omega) \cdot \boldsymbol{u}_n^H(\omega), \tag{1}
$$
in which, $\boldsymbol{u}_n(\omega)=[u^1_n(\omega), u^2_n(\omega), \cdots, u^M_n]^T$ is the Fourier spectra
of the $n_{th}$ segment data recorded by $M$ stations, $H$ denotes Hermitian transpose, and $N$ is the total number of data segments.
Then we create steering vector as follows,
$$
\boldsymbol{a}(\omega; \boldsymbol{s}, \boldsymbol{x}) = [e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_1}, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_2}, \cdots, e^{-i\omega \boldsymbol{s} \cdot \boldsymbol{x}_M}]^T, \tag{2}
$$</p>
<p>where, $\boldsymbol{s}$ and $\boldsymbol{x}_m$ separately indicate horizontal slowness (ray parameter for body waves) and position of the $m_{th}$ station.
The beam power is given by
$$
B(\omega; \boldsymbol{s}) = \boldsymbol{a}^H \boldsymbol{C}(\omega) \boldsymbol{a}. \tag{3}
$$
For more details about beamforming, someone can refer to <a href="https://geophydog.cool/post/cross_spectra_beamforing/">this blog</a>.</p>
<h3 id="an-example-of-locating-the-distant-p-wave-source">An Example of Locating the distant P wave source</h3>
<p>We first import required Python libraries.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">read</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">mpl_toolkits.basemap</span> <span class="kn">import</span> <span class="n">Basemap</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.signal.windows</span> <span class="kn">import</span> <span class="n">hann</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">obspy.taup</span> <span class="kn">import</span> <span class="n">TauPyModel</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The 13 seismic stations are installed in the center part of China, and we collect the data of March 10, 2008 to perform this work.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;2008-03-10/*BHZ.SAC&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">sta</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;X4_IRIS_BHZ.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fin</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sta</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="p">[]</span>        
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">[</span><span class="n">tmp</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colspan</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap1</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;cyl&#39;</span><span class="p">,</span> <span class="n">lon_0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap1</span><span class="o">.</span><span class="n">shadedrelief</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">bmap1</span><span class="p">(</span><span class="mi">106</span><span class="p">,</span> <span class="mi">34</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;#87CEFA&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap1</span><span class="o">.</span><span class="n">drawmeridians</span><span class="p">(</span><span class="n">meridians</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                  <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap1</span><span class="o">.</span><span class="n">drawparallels</span><span class="p">(</span><span class="n">circles</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                  <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colspan</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;merc&#39;</span><span class="p">,</span> <span class="n">llcrnrlat</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">llcrnrlon</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">urcrnrlon</span><span class="o">=</span><span class="mi">110</span><span class="p">,</span> <span class="n">urcrnrlat</span><span class="o">=</span><span class="mi">39</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span><span class="o">.</span><span class="n">shadedrelief</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">bmap2</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span><span class="o">.</span><span class="n">drawcoastlines</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;#87CEFA&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span><span class="o">.</span><span class="n">drawmeridians</span><span class="p">(</span><span class="n">meridians</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                  <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap2</span><span class="o">.</span><span class="n">drawparallels</span><span class="p">(</span><span class="n">circles</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                  <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/Array_Processing/NOISE_BODY_WAVE_01.png" alt="station map"></p>
<p>It is worth noting that we compute the beam power in Cartesian coordinate system while we only have the longitudes and latitudes of these stations.
Thus, we have to convert these longitudes and latitudes to Cartesian coordinates, so we define the following useful functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">la1</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">LA2</span><span class="p">,</span> <span class="n">LO2</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">6371</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">    <span class="n">dla</span> <span class="o">=</span> <span class="p">(</span><span class="n">LA2</span><span class="o">-</span><span class="n">la1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">dlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">LO2</span><span class="o">-</span><span class="n">lo1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dla</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlo</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">R</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">1e3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">azimuth</span><span class="p">(</span><span class="n">la1</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">LA2</span><span class="p">,</span> <span class="n">LO2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">    <span class="n">dla</span> <span class="o">=</span> <span class="p">(</span><span class="n">LA2</span> <span class="o">-</span> <span class="n">la1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">dlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">LO2</span> <span class="o">-</span> <span class="n">lo1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlo</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dlo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">th</span> <span class="o">/</span> <span class="n">d2r</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">lola2xy</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">lo0</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">la0</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">la0</span><span class="p">,</span> <span class="n">lo0</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">az</span> <span class="o">=</span> <span class="n">azimuth</span><span class="p">(</span><span class="n">la0</span><span class="p">,</span> <span class="n">lo0</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">az</span><span class="p">)</span> <span class="o">*</span> <span class="n">dist</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">az</span><span class="p">)</span> <span class="o">*</span> <span class="n">dist</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">new_xy</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nd</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">=</span> <span class="n">hann</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">-=</span> <span class="n">d</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="p">[:</span><span class="n">pn</span><span class="p">]</span> <span class="o">*=</span> <span class="n">h</span><span class="p">[:</span><span class="n">pn</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="n">pn</span><span class="p">:]</span> <span class="o">*=</span> <span class="n">h</span><span class="p">[</span><span class="o">-</span><span class="n">pn</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fd</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fd</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We need to estimate the average cross-spectral matrix of seismic data by this array before compute the beam power.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">st</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;2008-03-10/*BHZ.SAC&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">utcb</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
</span></span><span class="line"><span class="cl"><span class="n">utce</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>
</span></span><span class="line"><span class="cl"><span class="n">dt</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">;</span> <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">utcb</span> <span class="o">&gt;</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">utcb</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">utce</span> <span class="o">&lt;</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">utce</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>
</span></span><span class="line"><span class="cl">    <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="n">lola2xy</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">nd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">utce</span><span class="o">-</span><span class="n">utcb</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nd</span><span class="o">+</span><span class="mi">50</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">ti</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">n0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">-</span><span class="n">utcb</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">n0</span><span class="p">:</span> <span class="n">n0</span><span class="o">+</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">pt</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">;</span> <span class="n">pn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span> <span class="n">on</span> <span class="o">=</span> <span class="n">pn</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">hn</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">operator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">hn</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">hn</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">tmp_data</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">n1</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">n1</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pn</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">pn</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">],</span> <span class="n">operator</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">n1</span> <span class="o">+=</span> <span class="n">on</span>
</span></span><span class="line"><span class="cl"><span class="n">tmp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tmp_data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">9</span><span class="p">;</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">fn1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f1</span><span class="o">*</span><span class="n">pn</span><span class="o">/</span><span class="n">fs</span><span class="p">);</span> <span class="n">fn2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f2</span><span class="o">*</span><span class="n">pn</span><span class="o">/</span><span class="n">fs</span><span class="p">);</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">fn2</span> <span class="o">-</span> <span class="n">fn1</span> <span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fn1</span><span class="p">,</span> <span class="n">fn2</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">fn1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now we compute the beam power using formula $(1)$ to estimate the back-azmith and corresponding ray parameter of the potential body wave.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">101</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="mf">111194.92664455</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
</span></span><span class="line"><span class="cl"><span class="n">b1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b2</span> <span class="o">=</span> <span class="mi">360</span><span class="p">;</span> <span class="n">nb</span> <span class="o">=</span> <span class="mi">181</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="n">nb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fn1</span><span class="p">,</span> <span class="n">fn2</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">pn</span>
</span></span><span class="line"><span class="cl">            <span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">fn1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">cc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span> <span class="n">cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cc</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
</span></span><span class="line"><span class="cl">            <span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="n">cc</span> <span class="o">@</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Someone may find that we normalize the beam power using the number of frequency points and the number of stations, which results in
the coherence of signals caught by this array.
<img src="/Array_Processing/NOISE_BODY_WAVE_03.png" alt="beam coherence"></p>
<p>The maximum of backazimuth-slowness beam coherence panel suggests that the signal source comes from the direction ranging 315-360 degress with horizonral slowness ranging 4-6 sec/degree, and thus we identify this seismic phase as P wave. We calculate the ray parameter of P wave using the <a href="https://docs.obspy.org/packages/obspy.taup.html">taup module</a>, and the slowness-distance curve is shown by the following figure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">TauPyModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s1">&#39;iasp91&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="o">=</span> <span class="mf">0.02</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">95</span><span class="o">+</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">phase</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">    <span class="n">ar</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_travel_times</span><span class="p">(</span><span class="n">source_depth_in_km</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">distance_in_degree</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                               <span class="n">phase_list</span><span class="o">=</span><span class="n">phase</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ray_param</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">pw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#00BFFF&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Distance (degree)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Ray parameter (sec/degree)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">ls</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ray parameter of seismic phase P&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/Array_Processing/NOISE_BODY_WAVE_02.png" alt="slowness-distance"></p>
<p>According to the beam coherence and the slowness-distance curve of P wave, we estimate that the distance between the source location the seismic array center is about 70 degrees. We utilize grid-searching rule to find the source location by projecting the backazimuth-slowness beam coherence to geographical coordinates.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span><span class="n">la1</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">LA2</span><span class="p">,</span> <span class="n">LO2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">    <span class="n">dla</span> <span class="o">=</span> <span class="p">(</span><span class="n">LA2</span><span class="o">-</span><span class="n">la1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">dlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">LO2</span><span class="o">-</span><span class="n">lo1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dla</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlo</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">azimuth_matrix</span><span class="p">(</span><span class="n">la1</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">LA2</span><span class="p">,</span> <span class="n">LO2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
</span></span><span class="line"><span class="cl">    <span class="n">dla</span> <span class="o">=</span> <span class="p">(</span><span class="n">LA2</span> <span class="o">-</span> <span class="n">la1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">dlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">LO2</span> <span class="o">-</span> <span class="n">lo1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2r</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlo</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">la1</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LA2</span><span class="o">*</span><span class="n">d2r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dlo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">th</span> <span class="o">/</span> <span class="n">d2r</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">lo0</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">la0</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">ns</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">shape</span>
</span></span><span class="line"><span class="cl"><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ds</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">db</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">lo1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span><span class="p">;</span> <span class="n">lo2</span> <span class="o">=</span> <span class="mi">180</span><span class="p">;</span> <span class="n">nlo</span> <span class="o">=</span> <span class="mi">181</span>
</span></span><span class="line"><span class="cl"><span class="n">la1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">90</span><span class="p">;</span> <span class="n">la2</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="n">nla</span> <span class="o">=</span> <span class="mi">91</span>
</span></span><span class="line"><span class="cl"><span class="n">lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lo1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">nlo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">la</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">la1</span><span class="p">,</span> <span class="n">la2</span><span class="p">,</span> <span class="n">nla</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">LO</span><span class="p">,</span> <span class="n">LA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">AZ</span> <span class="o">=</span> <span class="n">azimuth_matrix</span><span class="p">(</span><span class="n">la0</span><span class="p">,</span> <span class="n">lo0</span><span class="p">,</span> <span class="n">LA</span><span class="p">,</span> <span class="n">LO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">DIST</span> <span class="o">=</span> <span class="n">distance_matrix</span><span class="p">(</span><span class="n">la0</span><span class="p">,</span> <span class="n">lo0</span><span class="p">,</span> <span class="n">LA</span><span class="p">,</span> <span class="n">LO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nla</span><span class="p">,</span> <span class="n">nlo</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nla</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlo</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DIST</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DIST</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pw</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.05</span> <span class="ow">or</span> <span class="n">pw</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ss</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">si</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">pw</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ss</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="n">ds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">ai</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">AZ</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">bb</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="n">db</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">bp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="n">ai</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;cyl&#39;</span><span class="p">,</span> <span class="n">lon_0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">LO</span><span class="p">,</span> <span class="n">LA</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;Cohenrence&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span><span class="o">.</span><span class="n">fillcontinents</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;#3CB371&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span><span class="o">.</span><span class="n">drawcoastlines</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">bmap</span><span class="p">(</span><span class="n">lo0</span><span class="p">,</span> <span class="n">la0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span><span class="o">.</span><span class="n">drawparallels</span><span class="p">(</span><span class="n">circles</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bmap</span><span class="o">.</span><span class="n">drawmeridians</span><span class="p">(</span><span class="n">meridians</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/Array_Processing/NOISE_BODY_WAVE_04.png" alt="source lacation">
This back-projection result shows that the possible source location is in the North Atlantic Ocean, which may relate to the irregular topography of the middle ocean rige in this place.</p>
<h3 id="perspective">Perspective</h3>
<p>We use this simple example to explain the process of using body waves from ambient noise cross-correlations to investigate the potential source locations of these indentified seismic phases. Indeed, it still holds many mysteries to reveal in the seismic ambient noise world. Thus, we will continue the journey of exploring the coupling process among the atmosphere, oceans and our solid planet Earth.</p>
<hr>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Geophydog</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/beamforming/">beamforming</a>
          <a href="/tags/body-wave/">body wave</a>
          <a href="/tags/source-location/">source-location</a>
          <a href="/tags/ambient-noise/">ambient noise</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/matched_field_processing/">
            <span class="next-text nav-default">Matched Field Processing: a generalized beamforming</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:geophydogvon@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/xuping-feng-7a0b01147/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/geophydog" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/feng-xu-ping-62" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://geophydog.cool/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2020 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>Geophydog All rights reserved</span>
  </span>
</div>


    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
