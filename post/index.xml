<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Geophydog</title>
    <link>https://geophydog.cool/post/</link>
    <description>Recent content in Posts on Geophydog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Geophydog All rights reserved</copyright>
    <lastBuildDate>Sat, 04 Jun 2022 09:41:56 +0800</lastBuildDate>
    
	<atom:link href="https://geophydog.cool/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Matched Field Processing: a generalized beamforming</title>
      <link>https://geophydog.cool/post/matched_field_processing/</link>
      <pubDate>Sat, 04 Jun 2022 09:41:56 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/matched_field_processing/</guid>
      <description>1. Basic descriptions Matched filed processing (MFP) is a location algorithm that was first applied in ocean acoustics (Baggeroer and Kuperman, 1988). It has been widely used to locate quakes or microseisms in seismology (e.g., Cros et al., 2011; Gal et al., 2018). We here give a short and simple derivation of MFP as follows.
1.1 MFP power Computing the Fourier spectrum vector, $$ \boldsymbol{u}(\omega) = [u_1(\omega), u_2(\omega), \cdots, u_N(\omega)]^T, \tag{1} $$ where, $N$ is the total number of receivers, $T$ means transpose operator, $u_i(\omega)$ is the Fourier spectrum of recordings by receiver $i$, and $\omega$ is angular frequency.</description>
    </item>
    
    <item>
      <title>Cross Spectral Beamforming in Ambient Noise Cross-correlation</title>
      <link>https://geophydog.cool/post/ncf_cross_spectral_beamforming/</link>
      <pubDate>Sat, 20 Mar 2021 15:33:02 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/ncf_cross_spectral_beamforming/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Estimating the Power Spectral Density of Ambient Seismic Noise</title>
      <link>https://geophydog.cool/post/psd_notes/</link>
      <pubDate>Thu, 11 Mar 2021 14:32:42 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/psd_notes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Geometry on a Sphere</title>
      <link>https://geophydog.cool/post/geometry_on_a_sphere/</link>
      <pubDate>Tue, 02 Mar 2021 16:05:43 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/geometry_on_a_sphere/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ocean and Climate Data Source</title>
      <link>https://geophydog.cool/post/data_source/</link>
      <pubDate>Tue, 26 Jan 2021 16:14:05 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/data_source/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Signal Stacking: Phase-Weighted Stack (PWS)</title>
      <link>https://geophydog.cool/post/signal_pws_stack/</link>
      <pubDate>Sat, 16 Jan 2021 11:17:54 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/signal_pws_stack/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Matlab GUI Design: popupmenu</title>
      <link>https://geophydog.cool/post/matlab_guide_popupmenu/</link>
      <pubDate>Wed, 06 Jan 2021 19:15:14 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/matlab_guide_popupmenu/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Matlab GUI Design: axes</title>
      <link>https://geophydog.cool/post/matlab_guide_axes/</link>
      <pubDate>Sat, 02 Jan 2021 15:26:48 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/matlab_guide_axes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Seismic Data Processing in Matlab</title>
      <link>https://geophydog.cool/post/seismic_data_processing_in_matlab/</link>
      <pubDate>Wed, 30 Dec 2020 15:29:30 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/seismic_data_processing_in_matlab/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Matlab GUI Design: the guide tool</title>
      <link>https://geophydog.cool/post/matlab_gui_guide/</link>
      <pubDate>Wed, 30 Dec 2020 12:29:18 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/matlab_gui_guide/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Useful seismic tools</title>
      <link>https://geophydog.cool/post/seismic_useful_tools/</link>
      <pubDate>Wed, 30 Dec 2020 09:31:49 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/seismic_useful_tools/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Obtain right Cross-Correlation spectrum</title>
      <link>https://geophydog.cool/post/cross-correlation_spectrum/</link>
      <pubDate>Mon, 28 Dec 2020 15:29:40 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/cross-correlation_spectrum/</guid>
      <description>1 Background Ambient seismic noise cross-correlation has far-reaching implications for the passive seismic surface wave imaging from regional to continental scales (e.g. Campillo &amp;amp; Paul, Shapiro &amp;amp; Campillo, 2004). Spectral analysis of cross-correlations is the key to retrieving reliable dispersion information about surface waves. Based on the Fourier spectra of event seismic surface wave data, however, we need to shift the cross-correlation time function before doing FFT to obtain the right spectra.</description>
    </item>
    
    <item>
      <title>Bessel functions numerical approximations</title>
      <link>https://geophydog.cool/post/bessel_functions_computation/</link>
      <pubDate>Fri, 25 Dec 2020 17:16:30 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/bessel_functions_computation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Array response function (Array transfer function)</title>
      <link>https://geophydog.cool/post/array_response_function/</link>
      <pubDate>Thu, 24 Dec 2020 11:42:11 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/array_response_function/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Multi-channel analysis of Surface waves (MASW)</title>
      <link>https://geophydog.cool/post/masw_phase_shift/</link>
      <pubDate>Wed, 23 Dec 2020 10:32:52 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/masw_phase_shift/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Vectors in GMT</title>
      <link>https://geophydog.cool/post/vectors_in_gmt/</link>
      <pubDate>Sun, 08 Nov 2020 18:31:43 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/vectors_in_gmt/</guid>
      <description>Arrow styles in Cartesian coordinate system 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  PS=plot.ps PDF=plot.pdf R=0/10/0/10 J=X10i/7i gmt psbasemap -R$R -J$J -K -Bx1f0.1 -By1f0.1 -BWSen &amp;gt; $PS echo &amp;#34;1 1 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+b &amp;gt;&amp;gt; $PS echo &amp;#34;1 2 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e &amp;gt;&amp;gt; $PS echo &amp;#34;1 3 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+b+e &amp;gt;&amp;gt; $PS echo &amp;#34;1 4 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+b+h1 &amp;gt;&amp;gt; $PS echo &amp;#34;1 5 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+h1 &amp;gt;&amp;gt; $PS echo &amp;#34;1 5 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+h1 -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;1 6 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+m -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;1 7 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+l -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;1 8 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+r -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;1 9 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+a90 -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;5 1 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+h-2 -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;5 2 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+h-1 -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;5 3 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+e+h2 -Gred &amp;gt;&amp;gt; $PS echo &amp;#34;5 4 0 2i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+b+e+h0 &amp;gt;&amp;gt; $PS echo &amp;#34;8 1 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+bt &amp;gt;&amp;gt; $PS echo &amp;#34;8 2 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+bc &amp;gt;&amp;gt; $PS echo &amp;#34;8 3 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+ba &amp;gt;&amp;gt; $PS echo &amp;#34;8 4 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+bA &amp;gt;&amp;gt; $PS echo &amp;#34;8 5 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+bi &amp;gt;&amp;gt; $PS echo &amp;#34;8 6 0 1i&amp;#34; | gmt psxy -R -J -K -O -Sv1c+bI &amp;gt;&amp;gt; $PS echo &amp;#34;5 5 2i 0 45&amp;#34; | gmt psxy -R -J -K -O -Sm1c+b+e+h1 -Gred&amp;gt;&amp;gt; $PS echo &amp;#34;5 7 2i 0 90&amp;#34; | gmt psxy -R -J -O -Sm1c+b+e+h1 -Gred &amp;gt;&amp;gt; $PS gmt psconvert -E150 -Tg -A -P $PS ps2pdf $PS $PDF evince $PDF rm $PS   Vectors in geographic coordinate system 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  R=-100/100/-70/70 J=M7i PS=geo_arrow.</description>
    </item>
    
    <item>
      <title>Boundary Conditions in PDE</title>
      <link>https://geophydog.cool/post/boundary_conditions/</link>
      <pubDate>Mon, 02 Nov 2020 20:44:01 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/boundary_conditions/</guid>
      <description>Boundary condition is necessary when we find the numerial solutions to some equations. Here, we show you some kinds of boundary contions in solving partial difference equation.
1 Dirichlet (fixed) $$ \left \{ \begin{aligned} p(t, x_{min}) &amp;amp;= 0\\
p(t, x_{max}) &amp;amp;= 0 \end{aligned} \right. \tag{1}, $$ where, $p(t, x)$ is what we want to find, let&amp;rsquo;s say, pressure in acoustic wave equation.
2 Neumann $$ \left \{ \begin{aligned} p(t, x_{min}) &amp;amp;= p(t, x_{min}+\Delta x)\\</description>
    </item>
    
    <item>
      <title>EGFs from Cross-correlations of Noise Excited by a Circle-Shaped Configuration of Sources</title>
      <link>https://geophydog.cool/post/ccf_noise_source/</link>
      <pubDate>Tue, 29 Sep 2020 13:43:54 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/ccf_noise_source/</guid>
      <description>New responses, if the wave field is diffuse, can be retrieved from interstaion cross-correlation of ambient noise. However, the cross-correlation time functions are asymmetric if the noise sources distribute unevenly. Here, we give you an example to show that how the cross-correlation functions vary with the angles of noise sources (red dots). We computed synthetic seismograms of earthquakes with angles from 1 to 360 degrees with an interval of 1 degree and data are recorded by two receivers (blue triangles); then we compute the cross-correlation time functions and align them with the angles; lastly, we stack all the cross-correlations to show you it&amp;rsquo;s symmetric under the condition that the noise sources distribute evenly.</description>
    </item>
    
    <item>
      <title>Calculating Ray Parameters Using Obspy</title>
      <link>https://geophydog.cool/post/obspy_ray_parameter/</link>
      <pubDate>Fri, 25 Sep 2020 08:56:35 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/obspy_ray_parameter/</guid>
      <description>Usually, we need to do back-projection from our back-azimuth $&amp;ndash;$ slowness panel of body waves to geographic locations. We&amp;rsquo;ll obtain the location of some body phase if we know the ray parameter of the body phase of corresponding epicentral distance. Here, we show you how to calculate the ray parameters versus the epicentral distances using the python library obspy.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  from obspy.</description>
    </item>
    
    <item>
      <title>How to Distribute and Install Your Own Python Package</title>
      <link>https://geophydog.cool/post/your_own_python_package/</link>
      <pubDate>Tue, 22 Sep 2020 20:12:37 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/your_own_python_package/</guid>
      <description>Python is very convenient for us to develop a package. How to install your own python package and import it like numpy or other packages? Here, we&amp;rsquo;ll give a very simple example to you.
1 Prepare your python package Create a empty directory called whatever, and here we name it Lib_Hello. Now give a name to your python package and we call it HelloPackage, and in directory HelloPackage, implement a python module.</description>
    </item>
    
    <item>
      <title>Numerical Modeling of Acoustic Wave Propagation</title>
      <link>https://geophydog.cool/post/acoustic_wave_modeling/</link>
      <pubDate>Mon, 21 Sep 2020 22:34:07 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/acoustic_wave_modeling/</guid>
      <description>1 Acoustic wave equation The acoustic wave equation in vector form is given by
$$ p_{tt}=c^2 \nabla^2 p \tag{1} $$
where, $p$ is the acoustic pressure, $c$ is the propagation speed of acoustic wave, $p_{tt}$ is the second time derivative of $p$, and $\nabla^2$ denotes the $Laplacian$ operator. We will discretize the equation using finite difference method in the following parts.
2 Propagation in 1D space The Taylar&amp;rsquo;s series of $p(t+\Delta t)$ and $p(t-\Delta t)$ are given by</description>
    </item>
    
    <item>
      <title>Seismic Data Processing in Python</title>
      <link>https://geophydog.cool/post/python_data_processing/</link>
      <pubDate>Sat, 19 Sep 2020 21:14:22 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/python_data_processing/</guid>
      <description>1 Obtaining Seismic Data Using Obspy 1.1 Basic usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  from obspy.clients.fdsn import Client from obspy.core import UTCDateTime # Create a data service from &amp;#39;IRIS&amp;#39; data center. client = Client(&amp;#39;IRIS&amp;#39;) # Setting the start time of waveforms. t1 = UTCDateTime(&amp;#39;2019-09-04T00:00:00&amp;#39;) # End time of waveforms: 3600 seconds shift relative to t1. t2 = t1 + 3600 # Get waveforms.</description>
    </item>
    
    <item>
      <title>Make Animations with Python</title>
      <link>https://geophydog.cool/post/make_animation_python/</link>
      <pubDate>Fri, 18 Sep 2020 17:36:40 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/make_animation_python/</guid>
      <description>1 The first animation Making animations using Python is very convenient and here we first implement the propagation of a sine or cosine function;
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import numpy as np import matplotlib.pyplot as plt from matplotlib import animation t = np.linspace(0, 3*np.pi, 61) s = np.sin(t) fig = plt.figure(figsize=(6, 3)) line, = plt.</description>
    </item>
    
    <item>
      <title>Settings in Python Plotting</title>
      <link>https://geophydog.cool/post/plotting_issues_in_python/</link>
      <pubDate>Fri, 18 Sep 2020 15:52:22 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/plotting_issues_in_python/</guid>
      <description>1 Pseudo-color map with polar projection We usually need to plot pseudo-color maps in polar projection besides except of those in Cartesian projection. Setting the projection as polar in method subplot. Here , we give an example of python code.
Example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import numpy as np import matplotlib.pyplot as plt theta = np.linspace(0, 2*np.pi, 121) r = np.</description>
    </item>
    
    <item>
      <title>The Journey to Digital Filter Design: One-way and Two-way Filters</title>
      <link>https://geophydog.cool/post/one-way_two-way_filter/</link>
      <pubDate>Wed, 16 Sep 2020 08:56:15 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/one-way_two-way_filter/</guid>
      <description>1 One-way filtering For given filter transfer function $H(\omega)$, the filtered data $X_1(\omega)$ is $$ \begin{cases} X_1(\omega) &amp;amp;= H(\omega) \cdot X(\omega)\\
x_1(t) &amp;amp;= \mathscr{R} \{ \mathscr{F}^{-1}[X_1(\omega)] \} \end{cases} \tag{1}. $$ Eq. $(1)$ is called $one-way$ filtering, and it ensure that the onsets of original and filtered signals are at the same moment.
2 Two-way filtering However, if we want to ensure that the peaks of original and filtered signals are at the same moment, we need to filter again, which is named $two-way$ filtering.</description>
    </item>
    
    <item>
      <title>The Journey to Digital Filter Design: Band-pass Filter</title>
      <link>https://geophydog.cool/post/band-pass_filter/</link>
      <pubDate>Tue, 15 Sep 2020 23:47:06 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/band-pass_filter/</guid>
      <description>1 Basic princeples To design a Butterworth band-pass filter, we can combine a low-pass filter and a high-pass filter as below, $$ H(z) = H_{lp}(z) \cdot H_{hp}(z) \tag{1}. $$ In previous blogs, we&amp;rsquo;ve gone over the Butterworth low-pass and high-pass filters. Here, we use the designed filters to construct a band-pass filter. You can also design a Butterworth band-stop filter according to the designed low-pass and high-pass filters if necessary. $$ \begin{cases} H_{lp}(z) &amp;amp;= H_{\omega_2}(z)\\</description>
    </item>
    
    <item>
      <title>The Journey to Digital Filter Design: High-pass Filter</title>
      <link>https://geophydog.cool/post/high-pass_filter/</link>
      <pubDate>Tue, 15 Sep 2020 23:42:50 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/high-pass_filter/</guid>
      <description>1 Basic princeples For a Butterworth high-pass filter, the squared frequency response is given by $$ |H(\omega)|^2 = \frac{1}{1+(\frac{tan\frac{\omega_c}{2}}{\frac{\omega}{2}})^{2N}} \tag{1}. $$ Using $tan\frac{\omega}{2}=\frac{1}{j}\frac{1-e^{-j\omega}}{1+e^{-j\omega}}$ and $z=e^{-j\omega}$, we have $$ |H(z)|^2=\frac{(-1)^N(\frac{1-z^{-1}}{1+z^{-1}})^{2N}}{(-1)^N(\frac{1-z^{-1}}{1+z^{-1}})^{2N}+tan^{2N}\frac{\omega_c}{2}} \tag{2}. $$ We know there $N$ repeated zeros $1$ of this transfer function, and the poles are little bit complicated. We first calculate $q_k=\frac{1-z_k^{-1}}{1+z^{-1}}$. $$ q_k= \begin{cases} &amp;amp;tan\frac{\omega_c}{2}e^{j\frac{2k+1}{2N}\pi}, \text{ for } N \text{ is even and }k=0, 1, 2, \cdots, 2N-1;\\</description>
    </item>
    
    <item>
      <title>Error Bars in GMT</title>
      <link>https://geophydog.cool/post/gmt_errorbar/</link>
      <pubDate>Mon, 14 Sep 2020 16:30:22 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/gmt_errorbar/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14  R=0/10/0/100 J=X5i/5i PS=error-bar-gmt.ps PDF=error-bar-gmt.pdf awk &amp;#39;BEGIN{for(i=2;i&amp;lt;10;i++){print i,i*i}}&amp;#39; &amp;gt; tmp.lst psxy -R$R -J$J -K -T &amp;gt; $PS psxy tmp.lst -R -J -K -O -B1:&amp;#34;X-axis&amp;#34;:/10:&amp;#34;Y-axis&amp;#34;:WSen -W1p,&amp;#34;--&amp;#34; &amp;gt;&amp;gt; $PS awk &amp;#39;{print $1,$2,3.5,1}&amp;#39; tmp.lst | psxy -R -J -K -O -Ey/3p &amp;gt;&amp;gt; $PS psxy tmp.lst -R -J -K -O -Si0.5c -Gblack &amp;gt;&amp;gt; $PS psxy -R -J -O -T&amp;gt;&amp;gt; $PS ps2pdf $PS $PDF   </description>
    </item>
    
    <item>
      <title>Print Colorful Strings in C</title>
      <link>https://geophydog.cool/post/colorful_strings_in_c/</link>
      <pubDate>Mon, 14 Sep 2020 16:25:13 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/colorful_strings_in_c/</guid>
      <description>It&amp;rsquo;s wonderful to print colorful strings on your terminal and here we show you how to do that.
1 2 3 4 5 6 7 8 9 10 11  #include &amp;lt;stdio.h&amp;gt; int main() { char ss[1024] = {&amp;#34;Colorful!!!&amp;#34;}; printf(&amp;#34;\033[0;31m %s \033[0;39m\n&amp;#34;, ss); // red  printf(&amp;#34;\033[0;32m %s \033[0;39m\n&amp;#34;, ss); // green  printf(&amp;#34;\033[0;33m %s \033[0;39m\n&amp;#34;, ss); // yellow  printf(&amp;#34;\033[0;34m %s \033[0;39m\n&amp;#34;, ss); // blue  printf(&amp;#34;\033[0;35m %s \033[0;39m\n&amp;#34;, ss); // purple  return 0; }   </description>
    </item>
    
    <item>
      <title>Function Pointer &amp; Pointer Function</title>
      <link>https://geophydog.cool/post/func_ptr_and_ptr_func/</link>
      <pubDate>Mon, 14 Sep 2020 16:12:24 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/func_ptr_and_ptr_func/</guid>
      <description>1 Ponter function Function pointer is a pointer in c, and it returns a pointer of some type. For instance, its declaration follows
1 2  int *f(int x, int y);   Let&amp;rsquo;s give a code demo to show function pointer.
1 2 3 4 5 6 7 8 9 10 11 12 13  int *add2Num() { int x = 10, y = 20; static int out[3] = {0}; out[0] = 10; out[1] = y; out[2] = x + y; return out; } int main() { int *p = NULL; p = add2Num(); printf(&amp;#34;%d\n&amp;#34;, *(p+1)); return 0; }   Output 20</description>
    </item>
    
    <item>
      <title>Awk notes</title>
      <link>https://geophydog.cool/post/awk_notes/</link>
      <pubDate>Sat, 12 Sep 2020 20:30:29 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/awk_notes/</guid>
      <description>1 Remove repeated lines Sometimes we want to remove these repeated lines according to some column(s).
1  awk &amp;#39;!a[$2,$3]++&amp;#39; pushLog.log   Above command will print the unique lines after removing repeated in columns 2 and 3.
For instance, there are some SAC files with same header gcarc, and can use the following command to achieve that.
1  saclst gcarc f *.SAC | sort -k2 -n -r | awk &amp;#39;!</description>
    </item>
    
    <item>
      <title>Basemap in Python</title>
      <link>https://geophydog.cool/post/basemap/</link>
      <pubDate>Sat, 12 Sep 2020 14:24:47 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/basemap/</guid>
      <description>1 Installation Here, the platforms are windows 10 and Anaconda-3.5.3.0 (Python 3.7).
 Open anaconda prompt type pip install geos to install library geos; Go https://www.lfd.uci.edu/~gohlke/pythonlibs/ to download two libraries: pyproj‑2.6.1.post1‑cp37‑cp37m‑win_amd64.whl and basemap‑1.2.2‑cp37‑cp37m‑win_amd64.whl Type commands: pip install pyproj‑2.6.1.post1‑cp37‑cp37m‑win_amd64.whl and pip install basemap‑1.2.2‑cp37‑cp37m‑win_amd64.whl  Now, we&amp;rsquo;ve installed Basemap and enjoy it!
2 The First Basemap 2.1 Satellite map 1 2 3 4 5 6 7 8 9 10 11 12 13  from mpl_toolkits.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geophydog.cool/post/nice_cover/</link>
      <pubDate>Sat, 12 Sep 2020 10:07:00 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/nice_cover/</guid>
      <description>Hello, there. Hope you have a nice journey. 1 1 2 3 4 5
2 2 3 4 5 6
3 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>The Journey to Digital Filter Design: Low-pass Filter</title>
      <link>https://geophydog.cool/post/low-pass_filter/</link>
      <pubDate>Fri, 11 Sep 2020 22:04:26 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/low-pass_filter/</guid>
      <description>Butterworth filters $$ |H(w)|^2=\frac{1}{1+( \frac{tan\frac{\omega}{2}} {tan\frac{\omega_c}{2}})^{2N}} \tag{1} $$
Low-pass filter Given the attenuation values $A_c$ and $A_r$ at cut-off frequencies $\omega_c$ and $\omega_r$, respectively, we first calculate the orders $N$ of filter. We know, $$ \begin{aligned} A_r &amp;amp;= -20lg|H(\omega_s)|\\
&amp;amp;= -20lg\frac{1}{\sqrt{1+(\frac{tan\frac{\omega _r}{2}}{\frac{\omega_c}{2}})^{2N}}} \end{aligned} \tag{2}, $$ and the orders $N$ is given by $$ N = \frac{1}{2}\frac{lg(10^{\frac{A_r}{10}}-1)}{lg(\frac{tan\frac{\omega_r}{2}}{tan\frac{\omega_c}{2}})} \tag{3}. $$ However, if you give the filter orders $N$, it can control the width of transition band of the filter.</description>
    </item>
    
    <item>
      <title>Cross-correlations From Seismic Ambient Noise</title>
      <link>https://geophydog.cool/post/cross_correlation_from_noise/</link>
      <pubDate>Tue, 08 Sep 2020 22:11:34 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/cross_correlation_from_noise/</guid>
      <description>New responses between station pairs can be extracted from diffuse wave field by cross-correlating ambient seismic noise or coda (Campillo &amp;amp; Paul, 2003; Bensen et al., 2007). However, some processing techniques should be taken into consideration to retrieve clear emperical green&amp;rsquo;s functions (EGFs). Here we show these steps in detail.
$\boxed{\text{Data processing steps}}$
1. Cut data 2. Removing mean, trend and tapering 3. Removing instrument response 4. Band-pass filtering 5. Temperal normalization $\boxed{\text{One-bit}}$ $$ \tilde{d_j}=sign(d_j) \tag{1} $$ $\boxed{\text{run absolute mean}}$ $$ \begin{aligned} w_j &amp;amp;= \frac{1}{2N+1}\sum_{n=j-N}^{j+N}|d_n| \\</description>
    </item>
    
    <item>
      <title>Cross Spectral Beamforming</title>
      <link>https://geophydog.cool/post/cross_spectra_beamforing/</link>
      <pubDate>Mon, 07 Sep 2020 22:40:07 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/cross_spectra_beamforing/</guid>
      <description>1 Basic principles Detection of coherent seismic signals is an interesting topic in seismology. However, it&amp;rsquo;s difficult to identify these coherent signals with single station because of the low signal to noise ratios (SNRs). Based on the array processing techniques in radial astronomy, radar and acoustics, the seismic array methods have been developed well in the past several decades. Here, we just follow the articles contributed by (Capon, 1970; Euler et al.</description>
    </item>
    
    <item>
      <title>Advanced Operations in Eigen3</title>
      <link>https://geophydog.cool/post/advanced_eigen3/</link>
      <pubDate>Sat, 05 Sep 2020 10:30:18 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/advanced_eigen3/</guid>
      <description>1 Matrix &amp;lt;-&amp;gt; C/C++ array 1.1 Matrix -&amp;gt; C/C++ array .data() stores the address, so we can give the address to a pointer.
1.2. C/C++ array -&amp;gt; Matrix Using Map to convert a C/C++ array to a Matrix.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include &amp;lt;iostream&amp;gt;#include &amp;lt;Eigen/Dense&amp;gt; using namespace Eigen; using namespace std; int main(int argc, char *argv[]){ int n; n = atoi(argv[1]); MatrixXf b(n, 1); b = MatrixXf::Random(n, 1); cout &amp;lt;&amp;lt; &amp;#34;b:\n&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; // convert Matrix b to C/C++ array c.</description>
    </item>
    
    <item>
      <title>Basic Operations in Eigen3 C&#43;&#43;</title>
      <link>https://geophydog.cool/post/eigen3_operations/</link>
      <pubDate>Fri, 04 Sep 2020 10:37:51 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/eigen3_operations/</guid>
      <description>1. Settings of Eigen 1.1 Here Eigen3  Type sudo apt-get install libeigen3-dev to install Eigen3. It will be installed in the default directory /usr/include/eigen3. Just copy Eigen under /usr/include/eigen3 to the directory /usr/include.  1.2 Header files 1 2  #include &amp;lt;Eigen/Dense&amp;gt;using namespace Eigen;   1.3 Tips MatrixXd m(r, c); &amp;ldquo;X&amp;rdquo; means &amp;ldquo;dynamic&amp;rdquo;, &amp;ldquo;d&amp;rdquo; means basic data type &amp;ldquo;double&amp;rdquo;， &amp;ldquo;r&amp;rdquo; and &amp;ldquo;c&amp;rdquo; indicate no. of rows an columns.</description>
    </item>
    
    <item>
      <title>Hilbert Transform</title>
      <link>https://geophydog.cool/post/hilbert_transform/</link>
      <pubDate>Thu, 03 Sep 2020 21:23:30 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/hilbert_transform/</guid>
      <description>Firstly, compute the FFT of real signal $x(n)$ $$ X(k) = \mathscr{F}[x(n)]=\sum_{n=0}^{N-1}x(n)e^{-\frac{i2\pi kn}{N}} \tag{1}. $$
Let the FFT of $h(n)$ be $H(k)$ to yield
$$ H(k)= \begin{cases} &amp;amp;X(k), &amp;amp;\text{ for } k=0 \\
&amp;amp;2X(k), &amp;amp;\text{ for } k=1, 2, \cdots, \frac{N}{2}-1 \\
&amp;amp;0, &amp;amp;\text{ for } k=\frac{N}{2}, \frac{N}{2}+1,\cdots, N-1 \end{cases} \tag{2}. $$
The hilbert transform $h(n)$ of the real signal $x(n)$ is given by
$$ h(n) = \mathscr{I} \{ \mathscr{F}^{-1}[H(k)] \} \tag{3}.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://geophydog.cool/post/about/</link>
      <pubDate>Thu, 03 Sep 2020 19:16:06 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/about/</guid>
      <description>Geophydog received his PhD degree @ SUSTech, and his research interests focus on multimodal surface waves, seismic interferometry, array seismology, oceanic noise source localization softwares for civil engineering purposes. This blog web is used to write down some academic notes for his researches and it comes with no WARRANTY!!!
Education 2023 &amp;ndash; present, postdoc, SUSTech
2019 &amp;ndash; 2023, PhD of Mechanics, Department of Earth and Space Sciences, Southern University of Science and Technology (SUSTech)</description>
    </item>
    
    <item>
      <title>Fourier Transform</title>
      <link>https://geophydog.cool/post/fourier_transform/</link>
      <pubDate>Thu, 03 Sep 2020 17:11:08 +0800</pubDate>
      
      <guid>https://geophydog.cool/post/fourier_transform/</guid>
      <description>1 Introduction The $Fourier \ Transform$ convert the signal in one domain to another domain, for instance from time domain to frequency domain. The definition of $Fourier \ Transform$ is given by $$ X(\omega) = \int_{-\infty}^\infty x(t)e^{-i \omega t} \tag{1}. $$
For the operation in programming, we need its discrete form, namely, $$ X(k) = \sum_{n=0}^{N-1}x(n) e^{\frac{-i2\pi kn}{N}} \tag{2}, $$ where, $k$ is the index of the $k_{th}$ frequency point, and we can find the $k_{th}$ frequency like this $$ f_k = \frac{kf_s}{N} \tag{3}, $$ $f_s$ is sampling rate of signal and $f_s=\frac{1}{\Delta t}$.</description>
    </item>
    
  </channel>
</rss>